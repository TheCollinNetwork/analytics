"use strict";
// Copyright 2023 LanceDB Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const mocha_1 = require("mocha");
const chai = require("chai");
const chai_1 = require("chai");
const chaiAsPromised = require("chai-as-promised");
const uuid_1 = require("uuid");
const lancedb = require("../index");
const os_1 = require("os");
const fs = require("fs");
const path = require("path");
chai.use(chaiAsPromised);
(0, mocha_1.describe)('LanceDB AWS Integration test', function () {
    it('s3+ddb schema is processed correctly', async function () {
        this.timeout(15000);
        // WARNING: specifying engine is NOT a publicly supported feature in lancedb yet
        // THE API WILL CHANGE
        const conn = await lancedb.connect('s3://lancedb-integtest?engine=ddb&ddbTableName=lancedb-integtest');
        const data = [{ vector: Array(128).fill(1.0) }];
        const tableName = (0, uuid_1.v4)();
        let table = await conn.createTable(tableName, data, { writeMode: lancedb.WriteMode.Overwrite });
        const futs = [table.add(data), table.add(data), table.add(data), table.add(data), table.add(data)];
        await Promise.allSettled(futs);
        table = await conn.openTable(tableName);
        chai_1.assert.equal(await table.countRows(), 6);
    });
});
(0, mocha_1.describe)('LanceDB Mirrored Store Integration test', function () {
    it('s3://...?mirroredStore=... param is processed correctly', async function () {
        this.timeout(600000);
        const dir = await fs.promises.mkdtemp(path.join((0, os_1.tmpdir)(), 'lancedb-mirror-'));
        console.log(dir);
        const conn = await lancedb.connect({ uri: `s3://lancedb-integtest?mirroredStore=${dir}`, storageOptions: { allowHttp: 'true' } });
        const data = Array(200).fill({ vector: Array(128).fill(1.0), id: 0 });
        data.push(...Array(200).fill({ vector: Array(128).fill(1.0), id: 1 }));
        data.push(...Array(200).fill({ vector: Array(128).fill(1.0), id: 2 }));
        data.push(...Array(200).fill({ vector: Array(128).fill(1.0), id: 3 }));
        const tableName = (0, uuid_1.v4)();
        // try create table and check if it's mirrored
        const t = await conn.createTable(tableName, data, { writeMode: lancedb.WriteMode.Overwrite });
        const mirroredPath = path.join(dir, `${tableName}.lance`);
        const files = await fs.promises.readdir(mirroredPath, { withFileTypes: true });
        // there should be three dirs
        chai_1.assert.equal(files.length, 3, 'files after table creation');
        chai_1.assert.isTrue(files[0].isDirectory());
        chai_1.assert.isTrue(files[1].isDirectory());
        const transactionFiles = await fs.promises.readdir(path.join(mirroredPath, '_transactions'), { withFileTypes: true });
        chai_1.assert.equal(transactionFiles.length, 1, 'transactionFiles after table creation');
        chai_1.assert.isTrue(transactionFiles[0].name.endsWith('.txn'));
        const versionFiles = await fs.promises.readdir(path.join(mirroredPath, '_versions'), { withFileTypes: true });
        chai_1.assert.equal(versionFiles.length, 1, 'versionFiles after table creation');
        chai_1.assert.isTrue(versionFiles[0].name.endsWith('.manifest'));
        const dataFiles = await fs.promises.readdir(path.join(mirroredPath, 'data'), { withFileTypes: true });
        chai_1.assert.equal(dataFiles.length, 1, 'dataFiles after table creation');
        chai_1.assert.isTrue(dataFiles[0].name.endsWith('.lance'));
        // try create index and check if it's mirrored
        await t.createIndex({ column: 'vector', type: 'ivf_pq' });
        const filesAfterIndex = await fs.promises.readdir(mirroredPath, { withFileTypes: true });
        // there should be four dirs
        chai_1.assert.equal(filesAfterIndex.length, 4, 'filesAfterIndex');
        chai_1.assert.isTrue(filesAfterIndex[0].isDirectory());
        chai_1.assert.isTrue(filesAfterIndex[1].isDirectory());
        chai_1.assert.isTrue(filesAfterIndex[2].isDirectory());
        // Two TXs now
        const transactionFilesAfterIndex = await fs.promises.readdir(path.join(mirroredPath, '_transactions'), { withFileTypes: true });
        chai_1.assert.equal(transactionFilesAfterIndex.length, 2, 'transactionFilesAfterIndex');
        chai_1.assert.isTrue(transactionFilesAfterIndex[0].name.endsWith('.txn'));
        chai_1.assert.isTrue(transactionFilesAfterIndex[1].name.endsWith('.txn'));
        const dataFilesAfterIndex = await fs.promises.readdir(path.join(mirroredPath, 'data'), { withFileTypes: true });
        chai_1.assert.equal(dataFilesAfterIndex.length, 1, 'dataFilesAfterIndex');
        chai_1.assert.isTrue(dataFilesAfterIndex[0].name.endsWith('.lance'));
        const indicesFiles = await fs.promises.readdir(path.join(mirroredPath, '_indices'), { withFileTypes: true });
        chai_1.assert.equal(indicesFiles.length, 1, 'indicesFiles');
        chai_1.assert.isTrue(indicesFiles[0].isDirectory());
        const indexFiles = await fs.promises.readdir(path.join(mirroredPath, '_indices', indicesFiles[0].name), { withFileTypes: true });
        console.log(`DEBUG indexFiles in ${indicesFiles[0].name}:`, indexFiles.map(f => `${f.name} (${f.isFile() ? 'file' : 'dir'})`));
        chai_1.assert.equal(indexFiles.length, 2, 'indexFiles');
        const fileNames = indexFiles.map(f => f.name).sort();
        chai_1.assert.isTrue(fileNames.includes('auxiliary.idx'), 'auxiliary.idx should be present');
        chai_1.assert.isTrue(fileNames.includes('index.idx'), 'index.idx should be present');
        chai_1.assert.isTrue(indexFiles.every(f => f.isFile()), 'all index files should be files');
        // try delete and check if it's mirrored
        await t.delete('id = 0');
        const filesAfterDelete = await fs.promises.readdir(mirroredPath, { withFileTypes: true });
        // there should be five dirs
        chai_1.assert.equal(filesAfterDelete.length, 5, 'filesAfterDelete');
        chai_1.assert.isTrue(filesAfterDelete[0].isDirectory());
        chai_1.assert.isTrue(filesAfterDelete[1].isDirectory());
        chai_1.assert.isTrue(filesAfterDelete[2].isDirectory());
        chai_1.assert.isTrue(filesAfterDelete[3].isDirectory());
        chai_1.assert.isTrue(filesAfterDelete[4].isDirectory());
        // Three TXs now
        const transactionFilesAfterDelete = await fs.promises.readdir(path.join(mirroredPath, '_transactions'), { withFileTypes: true });
        chai_1.assert.equal(transactionFilesAfterDelete.length, 3, 'transactionFilesAfterDelete');
        chai_1.assert.isTrue(transactionFilesAfterDelete[0].name.endsWith('.txn'));
        chai_1.assert.isTrue(transactionFilesAfterDelete[1].name.endsWith('.txn'));
        const dataFilesAfterDelete = await fs.promises.readdir(path.join(mirroredPath, 'data'), { withFileTypes: true });
        chai_1.assert.equal(dataFilesAfterDelete.length, 1, 'dataFilesAfterDelete');
        chai_1.assert.isTrue(dataFilesAfterDelete[0].name.endsWith('.lance'));
        const indicesFilesAfterDelete = await fs.promises.readdir(path.join(mirroredPath, '_indices'), { withFileTypes: true });
        chai_1.assert.equal(indicesFilesAfterDelete.length, 1, 'indicesFilesAfterDelete');
        chai_1.assert.isTrue(indicesFilesAfterDelete[0].isDirectory());
        const indexFilesAfterDelete = await fs.promises.readdir(path.join(mirroredPath, '_indices', indicesFilesAfterDelete[0].name), { withFileTypes: true });
        console.log(`DEBUG indexFilesAfterDelete in ${indicesFilesAfterDelete[0].name}:`, indexFilesAfterDelete.map(f => `${f.name} (${f.isFile() ? 'file' : 'dir'})`));
        chai_1.assert.equal(indexFilesAfterDelete.length, 2, 'indexFilesAfterDelete');
        const fileNamesAfterDelete = indexFilesAfterDelete.map(f => f.name).sort();
        chai_1.assert.isTrue(fileNamesAfterDelete.includes('auxiliary.idx'), 'auxiliary.idx should be present after delete');
        chai_1.assert.isTrue(fileNamesAfterDelete.includes('index.idx'), 'index.idx should be present after delete');
        chai_1.assert.isTrue(indexFilesAfterDelete.every(f => f.isFile()), 'all index files should be files after delete');
        const deletionFiles = await fs.promises.readdir(path.join(mirroredPath, '_deletions'), { withFileTypes: true });
        chai_1.assert.equal(deletionFiles.length, 1, 'deletionFiles');
        chai_1.assert.isTrue(deletionFiles[0].name.endsWith('.arrow'));
    });
});
//# sourceMappingURL=test.js.map